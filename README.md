# LITE Bootstrap Server

A proof-of-concept certificate authority (CA) and bootstrap server written
in Go.

This utility provides an authenticated REST API that can be used to:

- Validate and sign certificate signing requests (CSRs)
- Register devices on a 3rd party cloud service during certificate registration
- Provision devices with basic connection details (MQTT broker domain/port)
- List previously registered devices
- Check certificate validity

Certificate requests are logged to a local SQLite database (`CADB.db`).

Device registration hooks to cloud services and returned MQTT broker details
are currently based on Azure IoT Hub, which may be extended to other providers
in the future.

It also enables a basic TCP server (`mTLS TCP server`) that requests a client
certificate during the TLS handshake, verifying that the certificate has been
signed by the CA. This is only used for testing and proof of concept purposes.

> The REST API will only accept requests from client devices with access to the
  bootstrap certificate and private key generated by `setup-bootstrap.sh`
  further below in this guide. It's assumed that this certificate and key pair
  will be provisioned to devices in the factory. This only provides a nominal
  level of protection, but demonstrates a starting point for securing the
  server from unwanted access.

## Prerequisites

This project requires a recent version of go to compile and debug the server.

For platform-specific details on installing go, see: https://go.dev/doc/install

# Quick Setup

## Config Settings

You can override various config settings with a `.linaroca.toml` file in the
application root folder.

The `[server]` settings, which map to the command-line parameters shown with
`linaroca server --help`, are shown below as an example:

```toml
[server]
# Azure IoT Hub Settings
hubname = "azure-hub-name"
resourcegroup = "azure-resource-group"
mqttport = 8883

# CA port number (REST API)
port = 1443

# mTLS port number
mport = 8443
```

## Setting the Hostname

The hostname is important since it will be part of the subject line in
some certificates generated by LinaroCA. It must be consistent across the
deployment.

The application will attempt to determine the hostname to use based on the
following order of precedence:

1. Check for the `$CAHOSTNAME` environment variable
2. Check the system hostname (same value as `hostname` in shell)
3. Default to `localhost` as a last resort

Set the hostname before starting the server via:

```bash
$ export CAHOSTNAME='myhostname.local'
````

For local development, this can usually be set to `localhost`, but will need
to be changed when working with multiple machines or containers.

## Setup Scripts

Four bash scripts are provided:

### `setup-ca.sh`

This script creates the HTTP and CA keys and certificates.  This
should only need to be run once, and, in fact, will require existing
certs to have to be removed manually before it can be run again.

### `setup-bootstrap.sh`

This script creates the key pair used for device bootstrap.
This is needed to authenticate with the CA server, and the data placed
in `bootstrap_crt.txt` and `bootstrap_key.txt` will need to be
included in the device, or included in any attempts to connect to the REST
API using curl or wget.

The script can be run multiple times (after removing the generated
files), but only would need to be rerun after regenerating the CA
cert.

### `run-server.sh`

This script will start the CA server on port 1443.

### `new-device.sh`

This script creates a new device, and registers it with this CA.
The certificates for the device will be placed in the 'certs'
directory, along with the certificates above.

> This certificate is only useful for testing the CA, and generally will not
  be used in a production setting.

## Cleanup

You can remove all existing certificate artifacts via:

```bash
$ rm CADB.rb
$ rm -rf certs
```

# REST API

The REST API is a **work in progress**, and not fully implemented at present!

API based loosely on [CMP (RFC4210)](https://tools.ietf.org/html/rfc4210).

## `/api/v1/cr` Certification Request: **POST**

This API requires the Content-Type to be set on the post data, it will
return an error if given the default Content-Type, and it should be
set to either `application/cbor` or `application/json`.  The request
is identical, and merely differs in how the data is encoded.  A
request made in cbor will have a cbor reply, as will json.

The content type can be specified with wget by adding:

```
--header "Content-Type: application/cbor"
```

as an argument to wget.  The content type must match the encoding of
the posted file.

### Request with `application/cbor`

This endpoint is used to request a certificate for a new device,
providing a CSR payload wrapped in a single CBOR array:

```cddl
[ bstr ]
```

> You can generate the expected CBOR payload from a CSR file via the
> `make_csr_cbor.go` helper, for example:
> `go run make_csr_cbor.go -in DEVICE.csr -out DEVICE.cbor`.

```cbor
[
  b64'MIH9MIGlAgEAMEMxEjAQBgNVBAoMCWxvY2FsaG9zdDEtMCsGA1UEAwwkZThjNDdiNDItZjdmYy00ZGM4LWI1MzgtOTM0OTZiNjE5YTNjMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJ5aLGLJID8MVHCHEzQOlO63RvBaTy8lRbtkDODYPgDKBOuAHWXbytgjO32K8O282BK/Hl5eEKqcXcHerlxE2xKAAMAoGCCqGSM49BAMCA0cAMEQCIEFoH+NV9jXJA0PmctbCQ7FOBnE/aT9hmqBuvBq2kIhuAiAyKGAUIAzHDBZ+lY6WaJGh/56rzr4KprVtNYFGLHLs1g=='
]
```

The CA will assign and record a unique serial number for this certificate,
which can later be used to check the certificate status via the `cs/{serial}`
endpoint.

#### Response

Replies with a CBOR array containing the following fields:

```cddl
{
   1 => int,   ; Status.
   2 => bstr,  ; Certificate
}
```

- `Status` is an error code where `0` indicates success, and non-zero values
should be treated as an error.
- `Certificate` contains the BASE64-encoded certificate.

### Request with `application/json`

This endpoint is used to request a certificate for a new device, providing a
**BASE64-encoded CSR payload in a JSON wrapper** with the following format:

> You can generate the expected JSON payload from a CSR file via the
  `make_csr_json.go` helper.

```json
{
  "CSR":"MIH9MIGlAgEAMEMxEjAQBgNVBAoMCWxvY2FsaG9zdDEtMCsGA1UEAwwkZThjNDdiNDItZjdmYy00ZGM4LWI1MzgtOTM0OTZiNjE5YTNjMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJ5aLGLJID8MVHCHEzQOlO63RvBaTy8lRbtkDODYPgDKBOuAHWXbytgjO32K8O282BK/Hl5eEKqcXcHerlxE2xKAAMAoGCCqGSM49BAMCA0cAMEQCIEFoH+NV9jXJA0PmctbCQ7FOBnE/aT9hmqBuvBq2kIhuAiAyKGAUIAzHDBZ+lY6WaJGh/56rzr4KprVtNYFGLHLs1g=="
}
```

> :warning: The `CSR` field in the JSON payload is the BASE64 encoded byte
  array from the equivalent of a DER file, and doesn't include the text
  headers present in the PEM file generated by
  `openssl req -new -key UUID.key -out UUID.csr` in `new-device.sh`.
  `make_csr_json.go` takes care of the process of loading the human-readable
  PEM file, extracting the byte array for the CSR, and encoding the payload
  in the expected format, seen below.

The CA will assign and record a unique serial number for this certificate,
which can later be used to check the certificate status via the `cs/{serial}`
endpoint.

#### Response

Replies with a JSON array containing `Status`, and `Cert` fields:

- `Status` is an error code where `0` indicates success, and non-zero values
should be treated as an error.
- `Cert` contains the BASE64-encoded certificate.

```json
{
  "Status":0,
  "Cert":"MIIBtjCCAVugAwIBAgIIFrKA6WV+D5gwCgYIKoZIzj0EAwIwOjEUMBIGA1UEChMLTGluYXJvLCBMVEQxIjAgBgNVBAMTGUxpbmFyb0NBIFJvb3QgQ2VydCAtIDIwMjAwHhcNMjExMDI5MTI0MjM0WhcNMjIxMDI5MTI0MjM0WjBDMRIwEAYDVQQKEwlsb2NhbGhvc3QxLTArBgNVBAMTJGU4YzQ3YjQyLWY3ZmMtNGRjOC1iNTM4LTkzNDk2YjYxOWEzYzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABCeWixiySA/DFRwhxM0DpTut0bwWk8vJUW7ZAzg2D4AygTrgB1l28rYIzt9ivDtvNgSvx5eXhCqnF3B3q5cRNsSjQjBAMB0GA1UdDgQWBBSCv0wCNUXMXavfi15AbcCclDvfkzAfBgNVHSMEGDAWgBSxhUrvHyyKgHn5/FaoKd761df1tjAKBggqhkjOPQQDAgNJADBGAiEAjDVYvr1qBfvc0VFZcFLxwO/5XvnBh2jZFpL9ykKsCw8CIQDF3ne7yokRAHt0nn35CW/J3FclGYH9rBVCZr7FU+pzHg==",
}
```

## `/api/v1/p10cr` Certification Request from PKCS10: **POST**

This endpoint is used to request a certificate for a new device, posting a
PKCS#10 CSR file in **PEM format** (ex. `USER.csr` generated using the
commands found in `new-device.sh`) as part of the request.

The CA will assign and record a unique serial number for this certificate,
which can later be used to check the certificate status via the `cs/{serial}`
endpoint.

It will reply with a certificate file in PEM format or a status error in JSON,
depending on the input CSR provided.

Testing this endpoint with:

> The example belows assumes `MBP2021.local` as the local hostname. This
  value will vary from one machine to another.

```bash
$ curl -v --cacert certs/CA.crt  \
          --cert certs/BOOTSTRAP.crt \
          --key certs/BOOTSTRAP.key  \
          -F csrfile=@USER.csr       \
          --output USER.crt          \
          https://MBP2021.local:1443/api/v1/p10cr
```

should give you a `USER.crt` file in **PEM format**, which you can view via:

```bash
$ openssl x509 -in USER.crt -noout -text
```

## `api/v1/cs/{serial}` Certificate Status Request: **GET**

Requests the certificate status based on the supplied certificate serial number.

The serial number is generated by the CA during the certificate generation
process (`/ap1/v1/cr`), and is a unique timestamp-based 64-bit integer (ex.
`1635511354607407000`) that is added to the certificate before sending it back
to the requesting device.

It can be retrieved using the `/api/v1/ds/{uuid}` endpoint, or from a
certificate file directly via the serial number field, for example:

> The example belows assumes a specific device UUID, and `MBP2021.local` as
  the local hostname. These values will vary from one machine to another.

```bash
$ openssl x509 -in certs/a8c6f808-b659-4f88-affb-40498834c572.crt -noout -text
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 1648935985023194000 (0x16e2328abcaa9390)
    Signature Algorithm: ecdsa-with-SHA256
        Issuer: O=Linaro, LTD, CN=LRC - 20220330062226
        Validity
            Not Before: Apr  2 21:46:25 2022 GMT
            Not After : Apr  2 21:46:25 2023 GMT
        Subject: O=MBP2021.local, OU=LinaroCA Device Cert - Signing, CN=a8c6f808-b659-4f88-affb-40498834c572
        ...
```

Once you have the serial number, you can send a status request via:

```bash
$ curl -v --cacert certs/CA.crt  \
          --cert certs/BOOTSTRAP.crt \
          --key certs/BOOTSTRAP.key  \
          https://MBP2021.local:1443/api/v1/cs/1648935985023194000
```

This endpoint accepts requests in cbor (`application/cbor`) or json
(`application/json`), defaulting to JSON responses if no Content-Type is
provided. The response Content-Type will match the request type used.

### Responses

This endpoint will return the following responses:

- HTTP response code **200**
  - `{"status": "1"}`: Indicates that the serial number exists, and that the
    certificate is marked as **valid** in the CA database.
  - `{"status": "0"}`: Indicates that the serial number exists, but that the
    certificate is marked as **invalid** in the CA database (i.e., it has been
    **revoked**).
- HTTP response code **400** + `{"error": "<error msg>"}`, where error msg is:
  - `invalid request`: Poorly formatted serial number was provided
  - `invalid serial number`: No certificate matching supplied serial found
  - `bad request: Content-Type must be ...`: Invalid Content-Type provided

## `api/v1/ds/{uuid}` Device Status Request: **GET**

Checks if any valid certificates are associated with the specified UUID. If
any valid certificates are found, their serial number will be returned in
the response payload.

This endpoint accepts requests in cbor (`application/cbor`) or json
(`application/json`), defaulting to JSON responses if no Content-Type is
provided. The response Content-Type will match the request type used.

```bash
$ curl -v --cacert certs/CA.crt  \
          --cert certs/BOOTSTRAP.crt \
          --key certs/BOOTSTRAP.key  \
          https://MBP2021.local:1443/api/v1/ds/56d38f73-3f6f-4a59-86bc-d315a1ccc634
```

### Responses

This endpoint will return the following responses:

- HTTP response code **200**
  - `{"Status":0,"Serials":null}`: No valid certs found for UUID
  - `{"Status":1,"Serials":[1649073924922206000]}`: Valid cert(s) found for UUID
- HTTP response code **400** + `{"error": "<error msg>"}`, where error msg is:
  - `need a valid UUID`: Invalid or improperly formatted UUID was provided
  - `unable to query db for UUID`: error querying for database UUID (fatal)
  - `bad request: Content-Type must be ...`: Invalid Content-Type provided

## `api/v1/kur` Key Update Request: **POST**

Request an update to an existing (non-revoked and non-expired) certificate. An
update is a replacement certificate containing either a new subject public
key or the current subject public key.

## `api/v1/krr` Key Revocation Request: **POST**

Requests the revocation of an existing certificate registration.

## `api/v1/ccs` Clous Connectvity Settings: **GET**

Requests the cloud connectivity details for the MQTT broker associated with
your cloud infrastructure.

### Request with `application/cbor`

You can send a status request via:

```bash
$ curl -v --cacert certs/CA.crt  \
          --cert certs/BOOTSTRAP.crt \
          --key certs/BOOTSTRAP.key  \
          -H 'Content-Type: application/cbor' \
          -H 'Accept: application/cbor' \
          https://MBP2021.local:1443/api/v1/ccs
```

#### Response

Replies with a CBOR array containing the following fields:

```cddl
{
   1 => tstr,  ; Hubname
   2 => int,   ; Port
}
```

- `Hubname` contains the Azure IoT Hub hubname string.
- `Port` contains the Azure IoT Hub MQTT port number.

### Request with `application/json` (default)

You can send a status request via:

```bash
$ curl -v --cacert certs/CA.crt  \
          --cert certs/BOOTSTRAP.crt \
          --key certs/BOOTSTRAP.key  \
          https://MBP2021.local:1443/api/v1/ccs
```

#### Response

Replies with a JSON array containing the following fields:

```json
{
  "Hubname":"azure_hubname",
  "Port":8883
}
```

- `Hubname` contains the Azure IoT Hub hubname string.
- `Port` contains the Azure IoT Hub MQTT port number.

# Mutual TLS Test Server

A secondary TCP server is started up along with the main CA server to test
mutual TLS authentication using client certificates.

mutual TLS authentication requests a certificate from the connecting client
device that has been signed with the CA, adding an additional level of trust
on behalf of the server concerning the client device.

### Using a CA-signed client certificate

Once a user certificate has been generated (via `new-device.sh`), you can test
mTLS connections via:

> The example belows assumes a specific device UUID, and `MBP2021.local` as
  the local hostname. These values will vary from one machine to another.

```bash
$ openssl s_client \
  -cert certs/a8c6f808-b659-4f88-affb-40498834c572.crt \
  -key certs/a8c6f808-b659-4f88-affb-40498834c572.key \
  -CAfile certs/CA.crt \
  -connect MBP2021.local:8443
```

- The `cert` and `key` fields indicate the client certificate and key
- The `CAfile` field is the CA certificate

If the connection is successful, you should get the following response
at the end of the outptut:

```
Verify return code: 0 (ok)
```

And linaroca will display details about the client cert in the log output:

```bash
$ ./linaroca server start
Starting mTLS TCP server on MBP2021.local:8443
Starting CA server on port https://MBP2021.local:1443
Connection accepted from 127.0.0.1:50231
Client certificate:
- Issuer CN: LRC - 20220330062226
- Subject: CN=a8c6f808-b659-4f88-affb-40498834c572,
  OU=LinaroCA Device Cert - Signing,O=MBP2021.local
```

### Using an invalid client certificate

To test with an **invalid user certificate**, generate a new cert:

```bash
$ openssl ecparam -name prime256v1 -genkey -out USERBAD.key
$ openssl req -new -x509 -sha256 -days 365 \
  -key USERBAD.key -out USERBAD.crt \
  -subj "/O=Linaro, LTD/CN=MBP2021.local"
```

Then try the request again:

```bash
$ openssl s_client \
  -cert USERBAD.crt -key USERBAD.key \
  -CAfile certs/SERVER.crt\
  -connect MBP2021.local:8443
```

You should get the following error from linaroca:

```
Connection accepted from 127.0.0.1:50443
Client handshake error: tls: failed to verify client certificate: x509: certificate signed by unknown authority
```

# Troubleshooting

## FAQs

### `setup-bootstrap.sh` causes `Can't load /home/user/.rnd into RNG`

Run `openssl rand -writerand .rnd` to generate the missing .rnd file.
